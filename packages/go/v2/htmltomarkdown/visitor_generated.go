//go:build disabled

// Code generated by generate_visitor_callbacks.py; DO NOT EDIT.
// Generator: scripts/generate_visitor_callbacks.py
// Schema: crates/html-to-markdown-ffi/visitor_callbacks.yaml
// Template: crates/html-to-markdown-ffi/templates/go_bridge_callbacks.go.j2
//
// NOTE: This file is currently disabled via build tag because the generated
// visitor API uses different method names and struct fields than the existing
// visitor.go implementation. This is work-in-progress code that will be enabled
// once the visitor pattern is refactored for consistency.

package htmltomarkdown

/*
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#ifndef HTML_TO_MARKDOWN_TYPES_H
#define HTML_TO_MARKDOWN_TYPES_H

// Result type enumeration (matching FFI HtmlToMarkdownVisitResultType)
typedef enum {
    HTML_TO_MARKDOWN_VISIT_CONTINUE = 0,
    HTML_TO_MARKDOWN_VISIT_CUSTOM = 1,
    HTML_TO_MARKDOWN_VISIT_SKIP = 2,
    HTML_TO_MARKDOWN_VISIT_PRESERVE_HTML = 3,
    HTML_TO_MARKDOWN_VISIT_ERROR = 4
} HtmlToMarkdownVisitResultType;

// Forward declarations for C types
typedef struct {
    uint32_t node_type;
    const char* tag_name;
    const char* parent_tag;
    size_t depth;
    size_t index_in_parent;
    bool is_inline;
    bool is_first_child;
    bool is_last_child;
    bool has_siblings;
} html_to_markdown_node_context_t;

typedef struct {
    uint32_t result_type;
    char* custom_output;
    char* error_message;
} html_to_markdown_visit_result_t;

#endif // HTML_TO_MARKDOWN_TYPES_H
*/
import "C"
import (
	"unsafe"
)

// ElementStartCallback wraps the user's Go callback for element_start.
//
// Called before entering any HTML element (pre-order traversal)
// HTML elements: All elements
//
//export goElementStartCallback
func goElementStartCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.ElementStart == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	// Call the user's Go callback
	result := visitor.ElementStart(
		goCtx,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// LineBreakCallback wraps the user's Go callback for line_break.
//
// Called for line break elements
// HTML elements: <br>, <br/>
//
//export goLineBreakCallback
func goLineBreakCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.LineBreak == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	// Call the user's Go callback
	result := visitor.LineBreak(
		goCtx,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// HorizontalRuleCallback wraps the user's Go callback for horizontal_rule.
//
// Called for horizontal rule elements
// HTML elements: <hr>, <hr/>
//
//export goHorizontalRuleCallback
func goHorizontalRuleCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.HorizontalRule == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	// Call the user's Go callback
	result := visitor.HorizontalRule(
		goCtx,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// TableStartCallback wraps the user's Go callback for table_start.
//
// Called before processing a table element
// HTML elements: <table>
//
//export goTableStartCallback
func goTableStartCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.TableStart == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	// Call the user's Go callback
	result := visitor.TableStart(
		goCtx,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// DefinitionListStartCallback wraps the user's Go callback for definition_list_start.
//
// Called before processing a definition list
// HTML elements: <dl>
//
//export goDefinitionListStartCallback
func goDefinitionListStartCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.DefinitionListStart == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	// Call the user's Go callback
	result := visitor.DefinitionListStart(
		goCtx,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// FigureStartCallback wraps the user's Go callback for figure_start.
//
// Called before processing a figure element
// HTML elements: <figure>
//
//export goFigureStartCallback
func goFigureStartCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.FigureStart == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	// Call the user's Go callback
	result := visitor.FigureStart(
		goCtx,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// TextCallback wraps the user's Go callback for text.
//
// Called for each text node in the HTML document
// HTML elements: Text nodes
//
//export goTextCallback
func goTextCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Text == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Text(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// StrongCallback wraps the user's Go callback for strong.
//
// Called for strong/bold elements
// HTML elements: <strong>, <b>
//
//export goStrongCallback
func goStrongCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Strong == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Strong(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// EmphasisCallback wraps the user's Go callback for emphasis.
//
// Called for emphasis/italic elements
// HTML elements: <em>, <i>
//
//export goEmphasisCallback
func goEmphasisCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Emphasis == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Emphasis(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// StrikethroughCallback wraps the user's Go callback for strikethrough.
//
// Called for strikethrough elements
// HTML elements: <s>, <del>, <strike>
//
//export goStrikethroughCallback
func goStrikethroughCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Strikethrough == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Strikethrough(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// UnderlineCallback wraps the user's Go callback for underline.
//
// Called for underline elements
// HTML elements: <u>, <ins>
//
//export goUnderlineCallback
func goUnderlineCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Underline == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Underline(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// SubscriptCallback wraps the user's Go callback for subscript.
//
// Called for subscript elements
// HTML elements: <sub>
//
//export goSubscriptCallback
func goSubscriptCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Subscript == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Subscript(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// SuperscriptCallback wraps the user's Go callback for superscript.
//
// Called for superscript elements
// HTML elements: <sup>
//
//export goSuperscriptCallback
func goSuperscriptCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Superscript == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Superscript(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// MarkCallback wraps the user's Go callback for mark.
//
// Called for mark/highlight elements
// HTML elements: <mark>
//
//export goMarkCallback
func goMarkCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Mark == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Mark(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// CodeInlineCallback wraps the user's Go callback for code_inline.
//
// Called for inline code elements
// HTML elements: <code>
//
//export goCodeInlineCallback
func goCodeInlineCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cCode *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.CodeInline == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goCode := C.GoString(cCode)
	// Call the user's Go callback
	result := visitor.CodeInline(
		goCtx,		goCode,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// ElementEndCallback wraps the user's Go callback for element_end.
//
// Called after exiting any HTML element (post-order traversal)
// HTML elements: All elements
//
//export goElementEndCallback
func goElementEndCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOutput *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.ElementEnd == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOutput := C.GoString(cOutput)
	// Call the user's Go callback
	result := visitor.ElementEnd(
		goCtx,		goOutput,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// TableEndCallback wraps the user's Go callback for table_end.
//
// Called after processing a table element
// HTML elements: </table>
//
//export goTableEndCallback
func goTableEndCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOutput *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.TableEnd == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOutput := C.GoString(cOutput)
	// Call the user's Go callback
	result := visitor.TableEnd(
		goCtx,		goOutput,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// DefinitionTermCallback wraps the user's Go callback for definition_term.
//
// Called for definition term elements
// HTML elements: <dt>
//
//export goDefinitionTermCallback
func goDefinitionTermCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.DefinitionTerm == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.DefinitionTerm(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// DefinitionDescriptionCallback wraps the user's Go callback for definition_description.
//
// Called for definition description elements
// HTML elements: <dd>
//
//export goDefinitionDescriptionCallback
func goDefinitionDescriptionCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.DefinitionDescription == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.DefinitionDescription(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// DefinitionListEndCallback wraps the user's Go callback for definition_list_end.
//
// Called after processing a definition list
// HTML elements: </dl>
//
//export goDefinitionListEndCallback
func goDefinitionListEndCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOutput *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.DefinitionListEnd == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOutput := C.GoString(cOutput)
	// Call the user's Go callback
	result := visitor.DefinitionListEnd(
		goCtx,		goOutput,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// SummaryCallback wraps the user's Go callback for summary.
//
// Called for summary elements inside details
// HTML elements: <summary>
//
//export goSummaryCallback
func goSummaryCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Summary == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Summary(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// FigcaptionCallback wraps the user's Go callback for figcaption.
//
// Called for figcaption elements inside figure
// HTML elements: <figcaption>
//
//export goFigcaptionCallback
func goFigcaptionCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Figcaption == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Figcaption(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// LinkCallback wraps the user's Go callback for link.
//
// Called for anchor links
// HTML elements: <a href="...">
//
//export goLinkCallback
func goLinkCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cHref *C.char,	cText *C.char,	cTitle *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Link == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goHref := C.GoString(cHref)
	goText := C.GoString(cText)
	var goTitle *string
	if cTitle != nil {
		s := C.GoString(cTitle)
		goTitle = &s
	}
	// Call the user's Go callback
	result := visitor.Link(
		goCtx,		goHref,		goText,		goTitle,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// ImageCallback wraps the user's Go callback for image.
//
// Called for image elements
// HTML elements: <img src="..." alt="...">
//
//export goImageCallback
func goImageCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cSrc *C.char,	cAlt *C.char,	cTitle *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Image == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goSrc := C.GoString(cSrc)
	goAlt := C.GoString(cAlt)
	var goTitle *string
	if cTitle != nil {
		s := C.GoString(cTitle)
		goTitle = &s
	}
	// Call the user's Go callback
	result := visitor.Image(
		goCtx,		goSrc,		goAlt,		goTitle,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// CodeBlockCallback wraps the user's Go callback for code_block.
//
// Called for code block elements
// HTML elements: <pre><code>
//
//export goCodeBlockCallback
func goCodeBlockCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cLang *C.char,	cCode *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.CodeBlock == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	var goLang *string
	if cLang != nil {
		s := C.GoString(cLang)
		goLang = &s
	}
	goCode := C.GoString(cCode)
	// Call the user's Go callback
	result := visitor.CodeBlock(
		goCtx,		goLang,		goCode,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// ListItemCallback wraps the user's Go callback for list_item.
//
// Called for list item elements
// HTML elements: <li>
//
//export goListItemCallback
func goListItemCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOrdered C.bool,	cMarker *C.char,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.ListItem == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOrdered := bool(cOrdered)
	goMarker := C.GoString(cMarker)
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.ListItem(
		goCtx,		goOrdered,		goMarker,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// ListEndCallback wraps the user's Go callback for list_end.
//
// Called after processing a list element
// HTML elements: </ul>, </ol>
//
//export goListEndCallback
func goListEndCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOrdered C.bool,	cOutput *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.ListEnd == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOrdered := bool(cOrdered)
	goOutput := C.GoString(cOutput)
	// Call the user's Go callback
	result := visitor.ListEnd(
		goCtx,		goOrdered,		goOutput,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// BlockquoteCallback wraps the user's Go callback for blockquote.
//
// Called for blockquote elements
// HTML elements: <blockquote>
//
//export goBlockquoteCallback
func goBlockquoteCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cContent *C.char,	cDepth C.size_t,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Blockquote == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goContent := C.GoString(cContent)
	goDepth := uint(cDepth)
	// Call the user's Go callback
	result := visitor.Blockquote(
		goCtx,		goContent,		goDepth,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// CustomElementCallback wraps the user's Go callback for custom_element.
//
// Called for custom or unknown HTML elements
// HTML elements: Unknown elements
//
//export goCustomElementCallback
func goCustomElementCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cTagname *C.char,	cContent *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.CustomElement == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goTagname := C.GoString(cTagname)
	goContent := C.GoString(cContent)
	// Call the user's Go callback
	result := visitor.CustomElement(
		goCtx,		goTagname,		goContent,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// FormCallback wraps the user's Go callback for form.
//
// Called for form elements
// HTML elements: <form>
//
//export goFormCallback
func goFormCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cAction *C.char,	cMethod *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Form == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	var goAction *string
	if cAction != nil {
		s := C.GoString(cAction)
		goAction = &s
	}
	var goMethod *string
	if cMethod != nil {
		s := C.GoString(cMethod)
		goMethod = &s
	}
	// Call the user's Go callback
	result := visitor.Form(
		goCtx,		goAction,		goMethod,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// InputCallback wraps the user's Go callback for input.
//
// Called for input form elements
// HTML elements: <input>
//
//export goInputCallback
func goInputCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cInputtype *C.char,	cName *C.char,	cValue *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Input == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	var goInputtype *string
	if cInputtype != nil {
		s := C.GoString(cInputtype)
		goInputtype = &s
	}
	var goName *string
	if cName != nil {
		s := C.GoString(cName)
		goName = &s
	}
	var goValue *string
	if cValue != nil {
		s := C.GoString(cValue)
		goValue = &s
	}
	// Call the user's Go callback
	result := visitor.Input(
		goCtx,		goInputtype,		goName,		goValue,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// ButtonCallback wraps the user's Go callback for button.
//
// Called for button elements
// HTML elements: <button>
//
//export goButtonCallback
func goButtonCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cText *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Button == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goText := C.GoString(cText)
	// Call the user's Go callback
	result := visitor.Button(
		goCtx,		goText,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// AudioCallback wraps the user's Go callback for audio.
//
// Called for audio elements
// HTML elements: <audio>
//
//export goAudioCallback
func goAudioCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cSrc *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Audio == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	var goSrc *string
	if cSrc != nil {
		s := C.GoString(cSrc)
		goSrc = &s
	}
	// Call the user's Go callback
	result := visitor.Audio(
		goCtx,		goSrc,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// VideoCallback wraps the user's Go callback for video.
//
// Called for video elements
// HTML elements: <video>
//
//export goVideoCallback
func goVideoCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cSrc *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Video == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	var goSrc *string
	if cSrc != nil {
		s := C.GoString(cSrc)
		goSrc = &s
	}
	// Call the user's Go callback
	result := visitor.Video(
		goCtx,		goSrc,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// IframeCallback wraps the user's Go callback for iframe.
//
// Called for iframe elements
// HTML elements: <iframe>
//
//export goIframeCallback
func goIframeCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cSrc *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Iframe == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	var goSrc *string
	if cSrc != nil {
		s := C.GoString(cSrc)
		goSrc = &s
	}
	// Call the user's Go callback
	result := visitor.Iframe(
		goCtx,		goSrc,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// HeadingCallback wraps the user's Go callback for heading.
//
// Called for heading elements
// HTML elements: <h1> through <h6>
//
//export goHeadingCallback
func goHeadingCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cLevel C.uint,	cText *C.char,	cId *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Heading == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goLevel := uint32(cLevel)
	goText := C.GoString(cText)
	var goId *string
	if cId != nil {
		s := C.GoString(cId)
		goId = &s
	}
	// Call the user's Go callback
	result := visitor.Heading(
		goCtx,		goLevel,		goText,		goId,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// ListStartCallback wraps the user's Go callback for list_start.
//
// Called before processing a list element
// HTML elements: <ul>, <ol>
//
//export goListStartCallback
func goListStartCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOrdered C.bool,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.ListStart == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOrdered := bool(cOrdered)
	// Call the user's Go callback
	result := visitor.ListStart(
		goCtx,		goOrdered,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// TableRowCallback wraps the user's Go callback for table_row.
//
// Called for table row elements
// HTML elements: <tr>
//
//export goTableRowCallback
func goTableRowCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cCells **C.char,
	cCellsCount C.size_t,	cIsheader C.bool,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.TableRow == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goCells := make([]string, int(cCellsCount))
	{
		cArray := (*[1 << 30]*C.char)(unsafe.Pointer(cCells))
		for i := 0; i < int(cCellsCount); i++ {
			goCells[i] = C.GoString(cArray[i])
		}
	}
	goIsheader := bool(cIsheader)
	// Call the user's Go callback
	result := visitor.TableRow(
		goCtx,		goCells,		goIsheader,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// DetailsCallback wraps the user's Go callback for details.
//
// Called for details/disclosure elements
// HTML elements: <details>
//
//export goDetailsCallback
func goDetailsCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOpen C.bool,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.Details == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOpen := bool(cOpen)
	// Call the user's Go callback
	result := visitor.Details(
		goCtx,		goOpen,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}

// FigureEndCallback wraps the user's Go callback for figure_end.
//
// Called after processing a figure element
// HTML elements: </figure>
//
//export goFigureEndCallback
func goFigureEndCallback(
	userData unsafe.Pointer,
	ctx *C.html_to_markdown_node_context_t,	cOutput *C.char,) C.html_to_markdown_visit_result_t {
	// Extract the visitor from user data
	if userData == nil {
		return continueResult()
	}

	visitor := (*Visitor)(userData)
	if visitor.FigureEnd == nil {
		return continueResult()
	}

	// Convert C types to Go types
	goCtx := &NodeContext{
		NodeType:   NodeType(ctx.node_type),
		TagName:    C.GoString(ctx.tag_name),
		Depth:      int(ctx.depth),
		IsFirstChild: bool(ctx.is_first_child),
		IsLastChild:  bool(ctx.is_last_child),
		HasSiblings:  bool(ctx.has_siblings),
	}
	goOutput := C.GoString(cOutput)
	// Call the user's Go callback
	result := visitor.FigureEnd(
		goCtx,		goOutput,	)

	// Convert Go VisitResult to C result
	return visitResultToC(result)
}


// continueResult returns a Continue result.
func continueResult() C.html_to_markdown_visit_result_t {
	return C.html_to_markdown_visit_result_t{
		result_type:   C.HTML_TO_MARKDOWN_VISIT_CONTINUE,
		custom_output: nil,
		error_message: nil,
	}
}

// visitResultToC converts a Go VisitResult to C representation.
func visitResultToC(result VisitResult) C.html_to_markdown_visit_result_t {
	switch result.Type {
	case VisitContinue:
		return C.html_to_markdown_visit_result_t{
			result_type:   C.HTML_TO_MARKDOWN_VISIT_CONTINUE,
			custom_output: nil,
			error_message: nil,
		}
	case VisitCustom:
		return C.html_to_markdown_visit_result_t{
			result_type:   C.HTML_TO_MARKDOWN_VISIT_CUSTOM,
			custom_output: C.CString(result.CustomOutput),
			error_message: nil,
		}
	case VisitSkip:
		return C.html_to_markdown_visit_result_t{
			result_type:   C.HTML_TO_MARKDOWN_VISIT_SKIP,
			custom_output: nil,
			error_message: nil,
		}
	case VisitPreserveHtml:
		return C.html_to_markdown_visit_result_t{
			result_type:   C.HTML_TO_MARKDOWN_VISIT_PRESERVE_HTML,
			custom_output: nil,
			error_message: nil,
		}
	case VisitError:
		return C.html_to_markdown_visit_result_t{
			result_type:   C.HTML_TO_MARKDOWN_VISIT_ERROR,
			custom_output: nil,
			error_message: C.CString(result.ErrorMessage),
		}
	default:
		return continueResult()
	}
}
