//! Generated visitor callback implementations for C FFI.
//!
//! This file is AUTO-GENERATED by the code generator from visitor_callbacks.yaml.
//! DO NOT EDIT MANUALLY - all changes will be lost on next generation.
//!
//! Generator: scripts/generate_visitor_callbacks.py
//! Schema: crates/html-to-markdown-ffi/visitor_callbacks.yaml
//! Template: crates/html-to-markdown-ffi/templates/rust_ffi_callbacks.rs.j2

#![allow(clippy::too_many_arguments)]
#![allow(clippy::missing_safety_doc)]

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use std::ptr;

use html_to_markdown_rs::visitor::{HtmlVisitor, NodeContext, VisitResult};

use super::registry::{
    CVisitorWrapper, HtmlToMarkdownNodeContext, HtmlToMarkdownVisitResult,
    HtmlToMarkdownVisitResultType,
};

impl HtmlVisitor for CVisitorWrapper {
{% for callback in callbacks %}
    /// {{ callback.description }}
    ///
    /// HTML elements: {{ callback.html_elements }}
    /// Frequency: {{ callback.frequency }}
    fn visit_{{ callback.name }}(
        &self,
{%- for param in callback.parameters %}
{%- if param.name != 'ctx' %}

        {{ param.name }}: {% if param.type == 'string' %}{% if param.nullable %}&Option<String>{% else %}&str{% endif %}{% elif param.type == 'string_array' %}&[String]{% elif param.type == 'bool' %}bool{% elif param.type == 'u32' %}u32{% elif param.type == 'usize' %}usize{% endif %},
{%- endif %}
{%- endfor %}

        ctx: &NodeContext,
    ) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.{{ callback.name }}.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
{%- for param in callback.parameters %}
{%- if param.type == 'string' and param.name != 'ctx' %}
{%- if param.nullable %}

        // Convert Option<String> to *const c_char (nullable)
        let c_{{ param.name }} = {{ param.name }}.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("{{ callback.name }}: null byte in {{ param.name }}")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
{%- else %}

        // Convert &str to *const c_char (non-null)
        let c_{{ param.name }} = CString::new({{ param.name }})
            .expect("{{ callback.name }}: null byte in {{ param.name }}")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
{%- endif %}
{%- elif param.type == 'string_array' %}

        // Convert &[String] to NULL-terminated array of C strings
        let c_{{ param.name }}_vec: Vec<*const c_char> = {{ param.name }}
            .iter()
            .map(|s| {
                CString::new(s.as_str())
                    .expect("{{ callback.name }}: null byte in {{ param.name }} array")
                    .into_raw()
                    .cast::<c_char>()
                    .cast_const()
            })
            .chain(std::iter::once(ptr::null()))
            .collect();
        let c_{{ param.name }} = c_{{ param.name }}_vec.as_ptr();
{%- endif %}
{%- endfor %}

        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.{{ callback.name }}.unwrap())(
                self.callbacks.user_data,
                ptr::addr_of!(c_ctx),
{%- for param in callback.parameters %}
{%- if param.name != 'ctx' %}
{%- if param.type == 'string' or param.type == 'string_array' %}

                c_{{ param.name }},
{%- elif param.type == 'usize' %}

                {{ param.name }},
{%- else %}

                {{ param.name }},
{%- endif %}
{%- endif %}
{%- endfor %}

            )
        };
{%- for param in callback.parameters %}
{%- if param.type == 'string' and param.name != 'ctx' %}
{%- if param.nullable %}

        // Free nullable string if it was allocated
        if !c_{{ param.name }}.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_{{ param.name }}.cast_mut()));
            }
        }
{%- else %}

        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_{{ param.name }}.cast_mut()));
        }
{%- endif %}
{%- elif param.type == 'string_array' %}

        // Free string array elements (excluding null terminator)
        for ptr in c_{{ param.name }}_vec.iter().take({{ param.name }}.len()) {
            // SAFETY: Pointers were allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(ptr.cast_mut()));
            }
        }
{%- endif %}
{%- endfor %}

        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

{% endfor %}
}

/// Convert C-compatible `HtmlToMarkdownVisitResult` to Rust `VisitResult`.
fn convert_c_visit_result(result: HtmlToMarkdownVisitResult) -> VisitResult {
    match result.result_type {
        HtmlToMarkdownVisitResultType::Continue => VisitResult::Continue,
        HtmlToMarkdownVisitResultType::Custom => {
            if result.custom_output.is_null() {
                VisitResult::Continue
            } else {
                // SAFETY: custom_output is a malloc'd C string from the callback
                let output = unsafe {
                    CStr::from_ptr(result.custom_output)
                        .to_string_lossy()
                        .into_owned()
                };
                // Free the malloc'd string
                // SAFETY: custom_output was allocated with malloc by the callback
                unsafe {
                    libc::free(result.custom_output.cast::<libc::c_void>());
                }
                VisitResult::Custom(output)
            }
        }
        HtmlToMarkdownVisitResultType::Skip => VisitResult::Skip,
        HtmlToMarkdownVisitResultType::PreserveHtml => VisitResult::PreserveHtml,
        HtmlToMarkdownVisitResultType::Error => {
            if result.error_message.is_null() {
                VisitResult::Continue
            } else {
                // SAFETY: error_message is a malloc'd C string from the callback
                let message = unsafe {
                    CStr::from_ptr(result.error_message)
                        .to_string_lossy()
                        .into_owned()
                };
                // Free the malloc'd string
                // SAFETY: error_message was allocated with malloc by the callback
                unsafe {
                    libc::free(result.error_message.cast::<libc::c_void>());
                }
                VisitResult::Error(message)
            }
        }
    }
}
