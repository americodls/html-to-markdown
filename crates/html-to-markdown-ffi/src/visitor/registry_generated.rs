//! Generated visitor callback implementations for C FFI.
//!
//! This file is AUTO-GENERATED by the code generator from visitor_callbacks.yaml.
//! DO NOT EDIT MANUALLY - all changes will be lost on next generation.
//!
//! Generator: scripts/generate_visitor_callbacks.py
//! Schema: crates/html-to-markdown-ffi/visitor_callbacks.yaml
//! Template: crates/html-to-markdown-ffi/templates/rust_ffi_callbacks.rs.j2

#![allow(clippy::too_many_arguments)]
#![allow(clippy::missing_safety_doc)]

use std::ffi::{CStr, CString};
use std::os::raw::c_char;
use std::ptr;

use html_to_markdown_rs::visitor::{HtmlVisitor, NodeContext, VisitResult};

use super::registry::{
    CVisitorWrapper, HtmlToMarkdownNodeContext, HtmlToMarkdownVisitResult, HtmlToMarkdownVisitResultType,
};

impl HtmlVisitor for CVisitorWrapper {
    /// Called before entering any HTML element (pre-order traversal)
    ///
    /// HTML elements: All elements
    /// Frequency: high
    fn visit_element_start(&self, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.element_start.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.element_start.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx)) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for line break elements
    ///
    /// HTML elements: <br>, <br/>
    /// Frequency: medium
    fn visit_line_break(&self, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.line_break.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.line_break.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx)) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for horizontal rule elements
    ///
    /// HTML elements: <hr>, <hr/>
    /// Frequency: low
    fn visit_horizontal_rule(&self, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.horizontal_rule.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.horizontal_rule.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx)) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called before processing a table element
    ///
    /// HTML elements: <table>
    /// Frequency: low
    fn visit_table_start(&self, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.table_start.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.table_start.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx)) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called before processing a definition list
    ///
    /// HTML elements: <dl>
    /// Frequency: low
    fn visit_definition_list_start(&self, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.definition_list_start.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.definition_list_start.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx)) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called before processing a figure element
    ///
    /// HTML elements: <figure>
    /// Frequency: low
    fn visit_figure_start(&self, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.figure_start.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.figure_start.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx)) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for each text node in the HTML document
    ///
    /// HTML elements: Text nodes
    /// Frequency: very_high
    fn visit_text(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.text.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("text: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.text.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for strong/bold elements
    ///
    /// HTML elements: <strong>, <b>
    /// Frequency: medium
    fn visit_strong(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.strong.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("strong: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.strong.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for emphasis/italic elements
    ///
    /// HTML elements: <em>, <i>
    /// Frequency: medium
    fn visit_emphasis(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.emphasis.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("emphasis: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.emphasis.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for strikethrough elements
    ///
    /// HTML elements: <s>, <del>, <strike>
    /// Frequency: low
    fn visit_strikethrough(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.strikethrough.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("strikethrough: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.strikethrough.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for underline elements
    ///
    /// HTML elements: <u>, <ins>
    /// Frequency: low
    fn visit_underline(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.underline.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("underline: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.underline.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for subscript elements
    ///
    /// HTML elements: <sub>
    /// Frequency: low
    fn visit_subscript(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.subscript.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("subscript: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.subscript.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for superscript elements
    ///
    /// HTML elements: <sup>
    /// Frequency: low
    fn visit_superscript(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.superscript.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("superscript: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.superscript.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for mark/highlight elements
    ///
    /// HTML elements: <mark>
    /// Frequency: low
    fn visit_mark(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.mark.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("mark: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.mark.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for inline code elements
    ///
    /// HTML elements: <code>
    /// Frequency: medium
    fn visit_code_inline(&self, code: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.code_inline.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_code = CString::new(code)
            .expect("code_inline: null byte in code")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.code_inline.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_code) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_code.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called after exiting any HTML element (post-order traversal)
    ///
    /// HTML elements: All elements
    /// Frequency: high
    fn visit_element_end(&self, output: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.element_end.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_output = CString::new(output)
            .expect("element_end: null byte in output")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.element_end.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_output) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_output.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called after processing a table element
    ///
    /// HTML elements: </table>
    /// Frequency: low
    fn visit_table_end(&self, output: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.table_end.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_output = CString::new(output)
            .expect("table_end: null byte in output")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.table_end.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_output) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_output.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for definition term elements
    ///
    /// HTML elements: <dt>
    /// Frequency: low
    fn visit_definition_term(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.definition_term.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("definition_term: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.definition_term.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for definition description elements
    ///
    /// HTML elements: <dd>
    /// Frequency: low
    fn visit_definition_description(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.definition_description.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("definition_description: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.definition_description.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called after processing a definition list
    ///
    /// HTML elements: </dl>
    /// Frequency: low
    fn visit_definition_list_end(&self, output: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.definition_list_end.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_output = CString::new(output)
            .expect("definition_list_end: null byte in output")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.definition_list_end.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_output)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_output.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for summary elements inside details
    ///
    /// HTML elements: <summary>
    /// Frequency: low
    fn visit_summary(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.summary.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("summary: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.summary.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for figcaption elements inside figure
    ///
    /// HTML elements: <figcaption>
    /// Frequency: low
    fn visit_figcaption(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.figcaption.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("figcaption: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.figcaption.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for anchor links
    ///
    /// HTML elements: <a href="...">
    /// Frequency: high
    fn visit_link(&self, href: &str, text: &str, title: &Option<String>, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.link.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_href = CString::new(href)
            .expect("link: null byte in href")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("link: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Convert Option<String> to *const c_char (nullable)
        let c_title = title.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("link: null byte in title")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.link.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_href, c_text, c_title)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_href.cast_mut()));
        }
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Free nullable string if it was allocated
        if !c_title.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_title.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for image elements
    ///
    /// HTML elements: <img src="..." alt="...">
    /// Frequency: medium
    fn visit_image(&self, src: &str, alt: &str, title: &Option<String>, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.image.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_src = CString::new(src)
            .expect("image: null byte in src")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Convert &str to *const c_char (non-null)
        let c_alt = CString::new(alt)
            .expect("image: null byte in alt")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Convert Option<String> to *const c_char (nullable)
        let c_title = title.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("image: null byte in title")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.image.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_src, c_alt, c_title)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_src.cast_mut()));
        }
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_alt.cast_mut()));
        }
        // Free nullable string if it was allocated
        if !c_title.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_title.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for code block elements
    ///
    /// HTML elements: <pre><code>
    /// Frequency: medium
    fn visit_code_block(&self, lang: &Option<String>, code: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.code_block.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert Option<String> to *const c_char (nullable)
        let c_lang = lang.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("code_block: null byte in lang")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Convert &str to *const c_char (non-null)
        let c_code = CString::new(code)
            .expect("code_block: null byte in code")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.code_block.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_lang, c_code)
        };
        // Free nullable string if it was allocated
        if !c_lang.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_lang.cast_mut()));
            }
        }
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_code.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for list item elements
    ///
    /// HTML elements: <li>
    /// Frequency: medium
    fn visit_list_item(&self, ordered: bool, marker: &str, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.list_item.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_marker = CString::new(marker)
            .expect("list_item: null byte in marker")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("list_item: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.list_item.unwrap())(
                self.callbacks.user_data,
                ptr::addr_of!(c_ctx),
                ordered,
                c_marker,
                c_text,
            )
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_marker.cast_mut()));
        }
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called after processing a list element
    ///
    /// HTML elements: </ul>, </ol>
    /// Frequency: medium
    fn visit_list_end(&self, ordered: bool, output: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.list_end.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_output = CString::new(output)
            .expect("list_end: null byte in output")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.list_end.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), ordered, c_output)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_output.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for blockquote elements
    ///
    /// HTML elements: <blockquote>
    /// Frequency: medium
    fn visit_blockquote(&self, content: &str, depth: usize, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.blockquote.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_content = CString::new(content)
            .expect("blockquote: null byte in content")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.blockquote.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_content, depth)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_content.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for custom or unknown HTML elements
    ///
    /// HTML elements: Unknown elements
    /// Frequency: low
    fn visit_custom_element(&self, tag_name: &str, content: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.custom_element.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_tag_name = CString::new(tag_name)
            .expect("custom_element: null byte in tag_name")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Convert &str to *const c_char (non-null)
        let c_content = CString::new(content)
            .expect("custom_element: null byte in content")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.custom_element.unwrap())(
                self.callbacks.user_data,
                ptr::addr_of!(c_ctx),
                c_tag_name,
                c_content,
            )
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_tag_name.cast_mut()));
        }
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_content.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for form elements
    ///
    /// HTML elements: <form>
    /// Frequency: low
    fn visit_form(&self, action: &Option<String>, method: &Option<String>, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.form.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert Option<String> to *const c_char (nullable)
        let c_action = action.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("form: null byte in action")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Convert Option<String> to *const c_char (nullable)
        let c_method = method.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("form: null byte in method")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.form.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_action, c_method)
        };
        // Free nullable string if it was allocated
        if !c_action.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_action.cast_mut()));
            }
        }
        // Free nullable string if it was allocated
        if !c_method.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_method.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for input form elements
    ///
    /// HTML elements: <input>
    /// Frequency: low
    fn visit_input(
        &self,
        input_type: &Option<String>,
        name: &Option<String>,
        value: &Option<String>,
        ctx: &NodeContext,
    ) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.input.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert Option<String> to *const c_char (nullable)
        let c_input_type = input_type.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("input: null byte in input_type")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Convert Option<String> to *const c_char (nullable)
        let c_name = name.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("input: null byte in name")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Convert Option<String> to *const c_char (nullable)
        let c_value = value.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("input: null byte in value")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.input.unwrap())(
                self.callbacks.user_data,
                ptr::addr_of!(c_ctx),
                c_input_type,
                c_name,
                c_value,
            )
        };
        // Free nullable string if it was allocated
        if !c_input_type.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_input_type.cast_mut()));
            }
        }
        // Free nullable string if it was allocated
        if !c_name.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_name.cast_mut()));
            }
        }
        // Free nullable string if it was allocated
        if !c_value.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_value.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for button elements
    ///
    /// HTML elements: <button>
    /// Frequency: low
    fn visit_button(&self, text: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.button.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("button: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.button.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_text) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for audio elements
    ///
    /// HTML elements: <audio>
    /// Frequency: low
    fn visit_audio(&self, src: &Option<String>, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.audio.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert Option<String> to *const c_char (nullable)
        let c_src = src.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("audio: null byte in src")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.audio.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_src) };
        // Free nullable string if it was allocated
        if !c_src.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_src.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for video elements
    ///
    /// HTML elements: <video>
    /// Frequency: low
    fn visit_video(&self, src: &Option<String>, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.video.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert Option<String> to *const c_char (nullable)
        let c_src = src.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("video: null byte in src")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.video.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_src) };
        // Free nullable string if it was allocated
        if !c_src.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_src.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for iframe elements
    ///
    /// HTML elements: <iframe>
    /// Frequency: low
    fn visit_iframe(&self, src: &Option<String>, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.iframe.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert Option<String> to *const c_char (nullable)
        let c_src = src.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("iframe: null byte in src")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.iframe.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_src) };
        // Free nullable string if it was allocated
        if !c_src.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_src.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for heading elements
    ///
    /// HTML elements: <h1> through <h6>
    /// Frequency: medium
    fn visit_heading(&self, level: u32, text: &str, id: &Option<String>, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.heading.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_text = CString::new(text)
            .expect("heading: null byte in text")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Convert Option<String> to *const c_char (nullable)
        let c_id = id.as_ref().map_or(ptr::null(), |s| {
            CString::new(s.as_str())
                .expect("heading: null byte in id")
                .into_raw()
                .cast::<c_char>()
                .cast_const()
        });
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.heading.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), level, c_text, c_id)
        };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_text.cast_mut()));
        }
        // Free nullable string if it was allocated
        if !c_id.is_null() {
            // SAFETY: Pointer was allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(c_id.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called before processing a list element
    ///
    /// HTML elements: <ul>, <ol>
    /// Frequency: medium
    fn visit_list_start(&self, ordered: bool, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.list_start.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.list_start.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), ordered) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for table row elements
    ///
    /// HTML elements: <tr>
    /// Frequency: low
    fn visit_table_row(&self, cells: &[String], is_header: bool, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.table_row.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &[String] to NULL-terminated array of C strings
        let c_cells_vec: Vec<*const c_char> = cells
            .iter()
            .map(|s| {
                CString::new(s.as_str())
                    .expect("table_row: null byte in cells array")
                    .into_raw()
                    .cast::<c_char>()
                    .cast_const()
            })
            .chain(std::iter::once(ptr::null()))
            .collect();
        let c_cells = c_cells_vec.as_ptr();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe {
            (self.callbacks.table_row.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_cells, is_header)
        };
        // Free string array elements (excluding null terminator)
        for ptr in c_cells_vec.iter().take(cells.len()) {
            // SAFETY: Pointers were allocated by CString::into_raw above
            unsafe {
                drop(CString::from_raw(ptr.cast_mut()));
            }
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called for details/disclosure elements
    ///
    /// HTML elements: <details>
    /// Frequency: low
    fn visit_details(&self, open: bool, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.details.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result = unsafe { (self.callbacks.details.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), open) };
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }

    /// Called after processing a figure element
    ///
    /// HTML elements: </figure>
    /// Frequency: low
    fn visit_figure_end(&self, output: &str, ctx: &NodeContext) -> VisitResult {
        // Check if callback is registered
        if self.callbacks.figure_end.is_none() {
            return VisitResult::Continue;
        }

        // Convert NodeContext to C-compatible format
        let c_ctx = HtmlToMarkdownNodeContext::from_node_context(ctx);
        // Convert &str to *const c_char (non-null)
        let c_output = CString::new(output)
            .expect("figure_end: null byte in output")
            .into_raw()
            .cast::<c_char>()
            .cast_const();
        // Call the C callback
        // SAFETY: Callback function pointer is validated at registration time.
        // All pointer arguments are properly allocated and valid for the callback duration.
        #[allow(clippy::unwrap_used)]
        let result =
            unsafe { (self.callbacks.figure_end.unwrap())(self.callbacks.user_data, ptr::addr_of!(c_ctx), c_output) };
        // Free allocated string
        // SAFETY: Pointer was allocated by CString::into_raw above
        unsafe {
            drop(CString::from_raw(c_output.cast_mut()));
        }
        // Convert C result back to Rust VisitResult
        convert_c_visit_result(result)
    }
}

/// Convert C-compatible `HtmlToMarkdownVisitResult` to Rust `VisitResult`.
fn convert_c_visit_result(result: HtmlToMarkdownVisitResult) -> VisitResult {
    match result.result_type {
        HtmlToMarkdownVisitResultType::Continue => VisitResult::Continue,
        HtmlToMarkdownVisitResultType::Custom => {
            if result.custom_output.is_null() {
                VisitResult::Continue
            } else {
                // SAFETY: custom_output is a malloc'd C string from the callback
                let output = unsafe { CStr::from_ptr(result.custom_output).to_string_lossy().into_owned() };
                // Free the malloc'd string
                // SAFETY: custom_output was allocated with malloc by the callback
                unsafe {
                    libc::free(result.custom_output.cast::<libc::c_void>());
                }
                VisitResult::Custom(output)
            }
        }
        HtmlToMarkdownVisitResultType::Skip => VisitResult::Skip,
        HtmlToMarkdownVisitResultType::PreserveHtml => VisitResult::PreserveHtml,
        HtmlToMarkdownVisitResultType::Error => {
            if result.error_message.is_null() {
                VisitResult::Continue
            } else {
                // SAFETY: error_message is a malloc'd C string from the callback
                let message = unsafe { CStr::from_ptr(result.error_message).to_string_lossy().into_owned() };
                // Free the malloc'd string
                // SAFETY: error_message was allocated with malloc by the callback
                unsafe {
                    libc::free(result.error_message.cast::<libc::c_void>());
                }
                VisitResult::Error(message)
            }
        }
    }
}
